package lessons.Questions;

public class Basics {
    /*
    * 1. Сколько ключевых слов зарезервированно языком? Что это за слова?
    * Какие из них не используются?
    *
    * Java резервирует 50 слов, 2 из них не используются: const, goto.
    * Список слов:
    * 1) Примитивы: byte, short, int, long, char, float, double, boolean.
    * 2) Циклы и ветвления: if, else, switch, case, default, while, do, break, continue, for.
    * 3) Исключения: try, catch, finally, throw, throws.
    * 4) Области видимости: private, protected, public.
    * 5) Объявление/Импорт: import, package, class, interface, extends, implements, static,
    *    final, void, abstract, native.
    * 6) Создание/возврат/вызов: new, return, this, super.
    * 7) Многопоточность: synchronized, volatile.
    * 8) instanceof, enum, assert, transient, strictfp, const, goto.
    * */
    /*
    * 2. Из каких символов может состоять имя переменной (корректный идентификатор)?
    * Имя или идентификатор переменной — это последовательность из строчных и заглавных
    * латинских букв, цифр, а также символов «$» и «_». Имя переменной может начинаться
    * с любого из перечисленных символов, кроме цифры. Технически возможно начать имя переменной
    * также с «$» или «_», однако это запрещено соглашением по оформлению кода
    * в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда
    * не используется вообще. В соответствии с соглашением имя переменной должно начинаться
    * именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при
    * именовании переменных не допускаются.
    * */
    /*
    * 3. Что значит слово “инициализация”?
    * Инициализация (от англ. initialization, инициирование) — создание, активация, подготовка
    * к работе, определение параметров. Приведение программы или устройства в состояние
    * готовности к использованию. С точки зрения Java — выделение памяти под объект,
    * например при создании MyClass myClass = new MyClass(). Таким образом будет выделена
    * память под объект myClass (он будет инициализирован). Без инициализации (new MyClass())
    * запись MyClass myClass; просто резервирует имя (объявляется переменная myClass типа MyClass).
    * */
    /*
    * 4. На какие основные группы можно поделить типы данных?
    * Примитивные и ссылочные.
    * */
    /*
    * 5. Какие примитивные типы вы знаете?
    * byte (целые числа, 1 байт, [-128, 127])
    * short (целые числа, 2 байта, [-32768, 32767])
    * int (целые числа, 4 байта, [-2147483648, 2147483647])
    * long (целые числа, 8 байт, [-922372036854775808,922372036854775807])
    * float (вещественные числа, 4 байта)
    * double (вещественные числа, 8 байт)
    * char (символ Unicode, 2 байта, [0, 65536])
    * boolean (значение истина/ложь, используется int, зависит от JVM)
    *
    * 1 байт = 8 бит, т.е. byte = 1 байт = 8 бит = 2 в степени 8 = 256бит или диапазо от -128 до 127.
    * */
    /*
    * 6. Что вы знаете о преобразовании примитивных типов данных, есть ли
    * потеря данных, можно ли преобразовать логический тип?
    *
    * Преобразование может быть неявным и явным (приведение типов). Неявное преобразование
    * может выполняться если: типы совместимы (например — оба целочисленные) размер «принимающего»
    * типа больше чем у того, который преобразуется (так называемое «преобразование с расширением»)

        int a = 123454;
        double b =  a; //неявное преобразование - преобразование с расширением

        int a = 123454;
        double b =  a; //неявное преобразование - преобразование с расширением

        Явное преобразование имеет вид переменная_нового_типа = (новый_тип) имя переменной;
        int a;
        byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных

        int a;
        byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных

    Примеры:
        public static void typeConverterExample() {
            long a = 100L;
            double b = 300.0;
            Object ab = a + b;
            System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

            double c = 1000.05;
            long d = 1000;
            Object cd = c+d;
            System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
        }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

    public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

    При повышении типа byte>short; short>int; int>long; float>double; char>int
    информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).
    При различных операциях может происходить повышение типов в порядке «усиления» к более
    информативному типу. Например складывая int и double получим тип double. Но есть и особенность,
    например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double),
    а не более «длинный» тип. Аналогичный пример с вещественной частью:
    long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

    long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

    Кратко можно записать такие правила:
    1) byte, short, char в выражениях всегда повышаются до int
    2) если в выражении участвует тип long — то именно к этому типу будет приведён результат
    3) если в выражении участвует float — то результат приводится к float
    4) если один из операндов имеет тип double — то к этому типу будет приведён весь результат
    5) При выборе между длиной и возможностью сохранить дробную часть — будет выбрана дробная часть
    * */
    /*
    * 7. Какими значениями инициализируются переменные по умолчанию?
    * Числа инициализируются 0 или 0.0. Объекты (в том числе String) — null, char — \u0000; boolean — false;
    * class TestClass {
        int a; double b; float c; char d; String s; Object o; boolean e;

        @Override
        public String toString() {
           return "TestClass{" +
           "a=" + a + ", b=" + b + ", c=" + c + ", d=" + d + ", s='" + s + '\'' + ", o=" + o +", e=" + e +'}';
           }
        }
        TestClass testClass = new TestClass();
        System.out.println(testClass); //TestClass{a=0, b=0.0, c=0.0, d= , s='null', o=null, e=false}
    }
    * */
    /*
    * 8. Как передается значение переменной (по ссылке/значению)?
    * Постоянный холивар по этому вопросу, видимо, связан с переводом на русский язык
    * некоторых терминов, а так же работой Java с примитивами, строками и ссылочными
    * объектами. По английски всё звучит строго — Java is always pass-by-value. Обычно
    * спор вызывают особенности языка относящиеся к пониманию примитивов, ссылок и объектов
    * в Java (и то, что некоторые из них неизменяемые). Итак:
    * Java передает всё по значению. Java никогда не передает ничего по ссылке. Примитивы,
    * ссылки, null — всё передается по значению, не по «ссылке».
    * Передача по значению: Когда передается параметр в метод, то параметр копируется в
    * другую переменную и она передается в метод. Поэтому это и называется «передача
    * по значению».Передача по ссылке: Если мы передаем в метод ссылочный тип (объект),
    * то так же происходит передача копии этого объекта (ссылки), которая указывает на какую-либо
    * область памяти (можно назвать ссылку — «указателем»). Изменив что-то в области памяти,
    * будут изменены все объекты, которые ссылаются на эту область памяти. Отсюда идет
    * название «передача по ссылке», хотя передается всё то же значение, просто значением
    * является указатель на область памяти.

    Приведу пример с холивара на stackoverflow
    (http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value)
    и переведу на русский:

    Пусть мы имеем такую строчку, которая резервирует имя myDog под тип Dog.
    Dog myDog;

    Но это еще не физический объект, а только указатель на тип Dog. Теперь создадим (инициализируем) этот объект.
    Dog myDog = new Dog("Rover");
    foo(myDog);

    Теперь myDog действительно занимает область в памяти (пусть будет область Dog@42).
    Вызвав метод foo(myDog) мы передаем копию значения указателя на область памяти 42.
    public void foo(Dog someDog) {
        someDog.setName("Max");     // AAA
        someDog = new Dog("Fifi");  // BBB
        someDog.setName("Rowlf");   // CCC
    }

    В строчке //AAA мы поменяли значение в памяти 42 на «Max».
    В строчке //BBB мы создали новый объект, который теперь будет лежать в другой области памяти (пусть будет Dog@74).
    В строке //CCC мы поменяли значение в области памяти 74. Очевидно, что изначальный объект myDog@42 ничего об этом не
    знает, но он ссылается на уже измененную в строке //AAA область памяти и теперь будет возвращать имя «Max».
    Теперь другая засада — примитивы и строки.

        Когда передается примитив в метод, то передается также его копия (копия значения).
    int x = 5;
    int y = changeX(x)
    //x=5;
    //y=25;

    private int changeX(int value) {
    value = value * 5;
    return value;
    }

    Создали примитив x = 5. Передали в метод копию значения (т.е. 5). В методе умножили на
    число и вернули его. Значение примитива y будет равно 25, а значение примитива x = 5
    (т.е. не изменится). Всё дело в том, что мы передали значение (5), а не указатель на
    область памяти. Соответственно значение x и не должно было поменяться, т.к. мы его не
    меняли (в методе использовалась копия значения).

    Строки immutable, т.е. неизменяемые. Когда мы присваиваем строке новое значение, то в
    сегда будет создан новый объект в памяти.

    Еще один пример, что происходит при передаче параметра в метод:
    class TestClass {
            public ArrayList<Object> changeObjectValue(ArrayList<Object> objectValue) {
                objectValue.clear();
                objectValue.add(999);
                return objectValue;
            }

            public String changeStr(String str) {
                str = "NewString";
                return str;
            }

            public int changeX(int x) {
                x = x*5;
                return x;
            }
        }

        TestClass testClass = new TestClass();

        ArrayList<Object> value = new ArrayList<Object>();
        value.add(23);
        String str = "FirstString";
        int x = 2;
        System.out.println(value + " " + str + " " + x); //[23] FirstString 2

        ArrayList<Object> value2 = new ArrayList<Object>();
        value2 = value;
        value2 = testClass.changeObjectValue(value2);

        String str2 = str;
        str2 = testClass.changeStr(str2);

        int x2 = testClass.changeX(x);

        System.out.println(value + " " + str + " " + x); //[999] FirstString 2
        System.out.println(value2 + " " + str2 + " " + x2); //[999] NewString 10
        System.out.println(value.equals(value2) + " " + str.equals(str2) + " " + (x2 == x)); //true false false

    1) Создаем ссылочный объект value и добавляем в него объект (Integer=23). Так же создаем
    строку str = «FirstString» и примитивное число x= 2.
    2) Отдельно создаем объект value2 и выделяем под него память; Сейчас это выглядит
    что-то вроде value={ArrayList@450}, value2={ArrayList@453}, т.е. видно, что это разные
    ссылки на объекты (разные области памяти).
    3) value2={ArrayList@450}, value={ArrayList@450} после присвоения оба объекта ссылаются
    на одну область памяти. Теперь попытаемся изменить их с помощью методов в тестовом классе
    4) Объекты передаются по копии указателя на область памяти. Т.к. value и value2 указывают
    на один объект в памяти, то после изменения в методе changeObjectValue одного объекта, поменяется и второй.
    5) Строка (String) всегда создается новая. Хоть str2 = str и указывали на одну область
    вначале, но после изменения str2 на новое значение NewString, значение первой строки
    осталось прежним.
    6) Т.к. примитивные типы передаются по копии значения (в данном случае 2), то изменение
    в методе примитивного типа никак не отразилось на значении исходной переменной x
    (значение в области памяти для x осталось прежним.

    Если всё же остались вопросы, то гуглите по Java pass-by-value.
    * */
}
