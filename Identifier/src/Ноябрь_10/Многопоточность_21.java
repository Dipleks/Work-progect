package Ноябрь_10;

import java.util.concurrent.Phaser;

/*Phaser (фазер)*/
/*Phaser похож на циклический барьер, но выполняет другую ф-цию.
Предположим у нас есть несколько потоков, которые запущенны параллельно
из главного. Каждый из потоков с начало создает переменную,
затем присваивает значение, после чего выводит ее значение на
терминал. Условно разделим роботу потока на 3 фазы: создание,
присвоение, вывод. Мы хотим, чтобы потоки работали синхронно по
фазам. То бишь, потоки не продолжают работу до тех пор, пока
каждый из потоков не завершит фазу.
Он имеет большое количество методов, а также перегруженные конструкторы.
Конструкторы:
    Phaser() Phaser(int party)
Первый конструктор указывает нулевое количество сторон,
а второму конструктору передается параметр целочисленного типа
указывающий на количество зарегистрированных сторон. Сторона —
это объект который зарегистрированный для работы с фазами.
Зачем нужно два конструктора, будет рассмотрено в примере,
а пока взгляним на методы позволяющие делать фазы.

int register()
Данный метод вызывается из потока который хочет зарегистрироваться.
В результате возвращается номер зарегистрированной фазы.

int arrive()
Этот метод указывает что он завершил выполнение фазы, и
возвращает номер фазы, если же работа фазера закончена, он
возвращает отрицательное число. При вызове данного метода
поток не приостанавливает, а продолжает выполнятся.

int arriveAndAwaitAdvance()
Этот метод указывает что он завершил выполнение фазы и
приостанавливает текущий поток до момента, пока все потоки
не закончат выполнять данную фазу. Также он возвращает номер фазы.

int arriveAndDeregister()
Принцип работы данного метода аналогичен предыдущему,
но так же, он отменяет регистрацию. final int getPhase()
возвращает номер текущей фазы.*/
public class Многопоточность_21 {
/*Пример: у нас есть мойка, два мойщика и одно место куда мы
* можем загнать машину. Приехали 3 машины, оба мойщика моют
* первую, а остальные 2 машины ждут, как помыли 1ю, заежает 2,
* после 3!*/
    public static void main(String[] args) {
        Phaser phaser = new Phaser(2); //регистрируем наших мойщиков
        new Moichik(phaser);
        new Moichik(phaser);
    }
    static class Moichik extends Thread{
        Phaser phaser;
        public Moichik(Phaser phaser) { //создаем конструктор для начала работ мойщиков
            this.phaser = phaser;
            start();
        }
        @Override
        public void run() {  //ставим в очередь наши машины
            for (int i = 0; i < 3; i++) {
                System.out.println(getName()+" моет машину!");
                phaser.arriveAndAwaitAdvance(); //приостанавливает работу пока все мойщики не освободятся
            }
        }
    }
}
