package Ноябрь_08;
/*Переход состояний потока:
* NEW -> RUNNABLE <-> RUNNING -> DEAD
* RUNNING -> WAITING/BLOCKED/SLEEP -> RUNNABLE*/
/*1. Состояние потока: New
Когда мы создаем новый объект класса Thread, используя
оператор new, то поток находится в состоянии New.
В этом состоянии поток еще не работает.
* 2. Состояние потока: Runnable
Когда мы вызываем метод start() созданного объекта
Thread, его состояние изменяется на Runnable и
управление потоком передается Планировщику потоков
(Thread scheduler). Ли запустить эту нить мгновенно
или сохранить его в работоспособный пула потоков
перед запуском, это зависит от реализации ОС в
планировщик потоков.
* 3. Состояние потока: Running
Когда поток будет запущен, его состояние изменится на
Running. Планировщик потоков выбирает один поток из
своего общего пула потоков и изменяет его состояние
на Running. Сразу после этого процессор начинает
выполнение этого потока. Во время выполнения состояние
потока также может изменится на Runnable, Dead или Blocked.
* 4. Состояние потока: Blocked или Waiting
Поток может ждать другой поток для завершения своей
работы, например, ждать освобождения ресурсов или ввода-вывода.
В этом случае его состояние изменяется на Waiting. После
того, как ожидание потока закончилось, его состояние
изменяется на Runnable и он возвращается общий пул потоков.
* 5. Состояние потока: Dead
После того, как поток завершает выполнение, его состояние
изменяется на Dead, то есть он отработал свое и уже не нужен.*/
public class Многопоточность_2 {
    public static void main(String[] args) throws Exception{
        Dred dred = new Dred();
        dred.start();
        /*Можно отсрочить запуск метода, статическим методом sleep класса Thread:*/
        //Thread.sleep(3000); //3000 это миллисекунды (3 сек)
        //теперь наш "Метод" запуститься через 3 сек. после "Поток"
        /*При вызове Thread.sleep(3000); его необходимо поместить в try
        * или поместить наш метод в исключения (Exception)*/
        /*Можно задать приоритет нашему методу от 1 до 10, есть
        * три состояния MIN 1, NORM 5, MAX 10. Чем выше приоритет,
        * тем чаще выполняется поток!
        * Метод yield меняет состояние потока из running в runnable!
        * При запуске yield, мы как бы говорим java запусти сначало другой поток!*/
        Thread.yield(); //при запуске данной команды есть вероятность,
                        //что сначало запустится "Поток", а потом "Метод"
        /*"Метод" мы можем выполнить после завершения выполнения потока "Поток",
        * делается это при помощи метода join:*/
        dred.join();
        System.out.println("Метод");
        /*Статические методы, типа yield, вызываются только для текущего потока!
        * А не статические, типа join для всех.*/
    }
}
class Dred extends Thread {
    @Override
    public void run(){
        System.out.println("Поток");
    }
}